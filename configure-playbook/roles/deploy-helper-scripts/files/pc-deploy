#! /bin/bash
#! /usr/local/bin/pc-deploy DEPLOY_ENV STACK_CONF

# Set defaults
default_args() {
    ENV_SEARCH_DIR="/home/deploy"

    declare -g -A ARGS
    ARGS[STACK]=
    ARGS[ENV]=
    ARGS[COMPOSE]=
    ARGS[DETACH]="false"
    ARGS[PRUNE]=0
    ARGS[DRYRUN]=0
    ARGS[VERBOSE]=0
    ARGS[DEBUG]=0

    CORE_STACKS=("public" "swarm-cleanup" "traefik" "badbots" "cert-sync")
    STACKS=("catalog" "internal" "mariadb" "monitoring" "solr")
}
default_args

runhelp() {
    echo ""
    echo "Deploy stack using environment data and stack config file"
    echo ""
    echo "Usage:"
    echo "   pc-deploy [FLAGS] DEPLOY_ENV STACK_CONF"
    echo ""
    echo "Examples: "
    echo "   pc-deploy catprod-prod solr-cloud"
    echo "     Use the docker-compose.solr-cloud.yml and .env files at /home/deploy/catprod-prod"
    echo "     to deploy a stack called catprod-prod-solr"
    echo "   pc-deploy catprod-prod docker-compose.solr-cloud.yml"
    echo "     Use the docker-compose.solr-cloud.yml and .env files at /home/deploy/catprod-prod"
    echo "     to deploy a stack called catprod-prod-solr"
    echo "   pc-deploy core-stacks swarm-cleanup -n"
    echo "     Use the docker-compose.swarm-cleanup.yml and .env files at /home/deploy/core-stacks"
    echo "     to display the dry-run command for deploying the stack called swarm-cleanup"
    echo ""
    echo "ARGS:"
    echo "  DEPLOY_ENV"
    echo "      Required. Relative path to which environment directory should be used for selecting compose files within /home/deploy."
    echo "  STACK_CONF"
    echo "      Required. Stack configuration or Docker compose file to deploy within DEPLOY_ENV."
    echo "  -d|--detach"
    echo "      In deploying the stack, add the --detach=true flag to wait for stack convergence"
    echo "  --prune"
    echo "      In deploying the stack, add the --prune flag to prune missing unreferenced services"
    echo "  -n|--dry-run"
    echo "      Do not perform any actions, just dry-run the output."
    echo "  -v|--verbose"
    echo "      Show verbose output."
    echo "  --debug"
    echo "      Display debugging messages (should be set before passing command arguments)."
    echo ""
}

message() {
    LOG_TS=$(date +%Y-%m-%d\ %H:%M:%S)
    1>&2 echo "[${LOG_TS}] $*"
}
verbose() {
    [[ ${ARGS[DRYRUN]} -eq 1 ]] && DRYRUN="(dry-run) "
    [[ ${ARGS[VERBOSE]} -eq 1 ]] && message "${DRYRUN}$*"
}
error() {
    message "ERROR: $*"
}
debug() {
    [[ ${ARGS[DEBUG]} -eq 1 ]] && message "Debug: $*"
}
die() {
    error "$*"
    exit 1
}

# Print help message
if [[ -z "$1" || $1 == "-h" || $1 == "--help" || $1 == "help" ]]; then
    runhelp
    exit 0
fi

# Check if run as root
if [[ $USER != "deploy" && $EUID -ne 0 ]]; then
    die "The script must be run with sudo (unless using --help)."
fi

# Parse command arguments
parse_args() {
    local POSITION=0
    # Parse flag arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
        -h|--help)
            runhelp
            exit 0
            ;;
        -d|--detach)
            ARGS[DETACH]="true"
            shift;;
        --prune)
            ARGS[PRUNE]=1
            shift;;
        -n|--dry-run)
            ARGS[DRYRUN]=1
            ARGS[VERBOSE]=1
            shift;;
        -v|--verbose)
            ARGS[VERBOSE]=1
            shift;;
        --debug)
            ARGS[DEBUG]=1
            ARGS[VERBOSE]=1
            [[ -n "${ARGS[STACK]}${ARGS[ENV]}${ARGS[COMPOSE]}" ]] && \
                die "The --debug flag must be set before DEPLOY_ENV or STACK_CONF."
            shift;;
        *)
            case "${POSITION}" in
            0)
                ARGS[ENV]=$1
                if [[ ! -d "${ENV_SEARCH_DIR}"/"${ARGS[ENV]}" ]]; then
                    echo "ERROR: environment does not exist: ${ENV_SEARCH_DIR}/$1"
                    exit 1
                fi
                POSITION=1
                shift ;;
            1)
                # Find a compose file in ENV_SEARCH_DIR/ARGS[ENV] that matches the pattern
                set_compose "$1"
                set_stackname
                POSITION=2
                shift ;;
            2)
                echo "ERROR: Unknown argument: $1"
                runhelp
                exit 1
            esac
        esac
    done
}

# Does additional validation of the values in the command parameters
# and will exit if not met
catch_invalid_args() {
    # Check for missing arguments
    [[ -z "${ARGS[ENV]}" ]] \
        && die "DEPLOY_ENV is a required argument"
    [[ -z "${ARGS[COMPOSE]}" ]] \
        && die "STACK_CONF is a required arugment and must be a valid stack config file name"

    # Check for missing derived values
    [[ -z "${ARGS[STACK]}" ]] \
        && die "The docker stack could not be determined from the provided STACK_CONF: ${ARGS[COMPOSE]}"

    # Check for invalid paths
    [[ ! -f "${ARGS[COMPOSE]}" ]] \
        && die "Compose file not found at ${ARGS[COMPOSE]}"
}

# Find the compose file given the patten (which may be the whole compose file name)
# $1 (string) pattern to match
set_compose() {
    debug "set_compose called with args {1}=$1"
    ARGS[COMPOSE]=""
    if [[ -f "${ENV_SEARCH_DIR}"/"${ARGS[ENV]}"/"docker-compose.${1}.yml" ]]; then
        debug "set_compose match on docker-compose.{1}.yml"
        ARGS[COMPOSE]="${ENV_SEARCH_DIR}/${ARGS[ENV]}/docker-compose.${1}.yml"
    fi

    FULL_MATCH="$(find "${ENV_SEARCH_DIR}"/"${ARGS[ENV]}" -type f -name "*${1}*" 2>/dev/null)"
    if [[ $(wc -l <<< "$FULL_MATCH") -eq 1 ]]; then
        debug "set_compose match on *{1}*"
        ARGS[COMPOSE]="$FULL_MATCH"
    fi
    debug "set_compose set variable COMPOSE=${ARGS[COMPOSE]}"
}

# Set the stack name variable based of the set compose file
set_stackname() {
    debug "set_stackname called"
    ARGS[STACK]=
    # Check if it is a core stack
    for IDX in "${!CORE_STACKS[@]}"; do
        if [[ ${ARGS[COMPOSE]##*/} == *"${CORE_STACKS[$IDX]}"* ]]; then
            debug "set_stackname core stack match against: *${CORE_STACKS[$IDX]}*"
            ARGS[STACK]="${CORE_STACKS[$IDX]}"
            break
        fi
    done
    # Check if it is an environment stack
    for IDX in "${!STACKS[@]}"; do
        if [[ ${ARGS[COMPOSE]##*/} == *"${STACKS[$IDX]}"* ]]; then
            debug "set_stackname regular stack match against: *${STACKS[$IDX]}*"
            ARGS[STACK]="${ARGS[ENV]}-${STACKS[$IDX]}"
            break
        fi
    done
    debug "set_stackname set variable STACK=${ARGS[STACK]}"
}

run_command() {
    if [[ $USER != "deploy" ]]; then
        SUDO_PREFIX=(sudo -Hu deploy)
    fi
    # XXX The EXTRA_ARGS are just strings added to command. Not currently safe for special chars or spaces.
    EXTRA_ARGS=("--with-registry-auth" "--detach=${ARGS[DETACH]}")
    if [[ ${ARGS[PRUNE]} -eq 1 ]]; then
        EXTRA_ARGS+=("--prune")
    fi
    CMD="docker stack deploy ${EXTRA_ARGS[*]} -c <(source \"${VAR_FILE}\"; envsubst < \"${ARGS[COMPOSE]}\") \"${ARGS[STACK]}\""
    verbose "Command:   ${SUDO_PREFIX[*]} bash -c '$CMD'"
    ([[ ${ARGS[DRYRUN]} -eq 0 ]] && "${SUDO_PREFIX[@]}" bash -c "$CMD") || true
}

# Deploy the Docker stack, exiting unsuccessfully if the deploy fails
main() {
    declare -g VAR_FILE="${ENV_SEARCH_DIR}/${ARGS[ENV]}/.env"
    verbose "Stack:     ${ARGS[STACK]}"
    verbose "Compose:   ${ARGS[COMPOSE]}"
    verbose "Variables: ${VAR_FILE}"
    
    if ! OUTPUT=$(run_command); then
        die "Failed to deploy stack. ${OUTPUT}"
    fi
    # Show output of the deploy command if verbose enabled
    [[ -n ${OUTPUT} ]] && verbose "${OUTPUT}"
    verbose "Deploy complete!"
    exit 0  # XXX this is needed as verbose can return false
}

# Parse and start running
parse_args "$@"
catch_invalid_args
main
