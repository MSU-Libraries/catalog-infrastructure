#!/bin/bash


# disabling SC2034 because of un-used color codes
# shellcheck disable=SC2155,SC2029,SC2034


# Color codes to use in messages
# Examples:
#   print_info "${BOLD}My bold message${RESET} Not bold"
#   print_info "${BOLD}${RED}My bold and red message${RESET} Normal text"
BLACK='\x1B[0;30m'
RED='\x1B[0;31m'
GREEN='\x1B[0;32m'
BROWN='\x1B[0;33m'
BLUE='\x1B[0;34m'
PURPLE='\x1B[0;35m'
CYAN='\x1B[0;36m'
LGRAY='\x1B[0;37m'
GRAY='\x1B[1;30m'
LRED='\x1B[1;31m'
LGREEN='\x1B[1;32m'
YELLOW='\x1B[1;33m'
LBLUE='\x1B[1;34m'
LPURPLE='\x1B[1;35m'
LCYAN='\x1B[1;36m'
WHITE='\x1B[1:37m'
BOLD='\033[1m'
RESET='\x1B[0m\033[0m'

please_do_not_run_me() {
    # This script is a place to stored shared variables and functions used by other scripts.
    # Do not run this script directly; it does nothing.
    if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
        declare SCRIPT_NAME=$( basename "$0" )
        echo "The $SCRIPT_NAME script is not intended to be run directly. Rather it contains"
        echo "shared code sourced by other pc-* scripts."
        exit 1
    fi
}
please_do_not_run_me

# Init log level variables, setting default log level
# If unspecified, the log level will be 1 (WARNING)
init_log_level() {
    declare -g LOG_LEVEL=${1:-1}
    declare -g -r MSG_ERROR=-1
    # shellcheck disable=SC2034
    declare -g -r MSG_QUIET=0
    declare -g -r MSG_WARNING=1
    declare -g -r MSG_INFO=2
    declare -g -r MSG_VERBOSE=3
    declare -g -r MSG_DEBUG=4
}

# Call all other functions starting with `init_args_` with intent
# to declare and initialize defaults for argument variables
init_args() {
    declare -a INIT_ARGS_FUNCS
    readarray -t INIT_ARGS_FUNCS < <(list_funcs_startswith init_args_)
    for INIT_ARGS_FUNC in "${INIT_ARGS_FUNCS[@]}"; do
        $INIT_ARGS_FUNC
    done
}

# Print script messages to stderr, requires var MSG_LEVEL be set
# Not to be called directly; use other print_* function instead.
_print_text() {
    # shellcheck disable=SC2153
    if [[ $LOG_LEVEL -ge $MSG_LEVEL || $LOG_LEVEL -lt 0 ]]; then
        declare LOG_TS=$(date +%Y-%m-%d\ %H:%M:%S)
        declare MSG="[${LOG_TS}] $*"
        1>&2 echo -e "$MSG"
    fi
}
print_warning() {
    MSG_LEVEL="$MSG_WARNING" _print_text "WARNING:" "$@"
}
print_info() {
    MSG_LEVEL="$MSG_INFO" _print_text "$@"
}
print_verbose() {
    MSG_LEVEL="$MSG_VERBOSE" _print_text "$@"
}
print_debug() {
    MSG_LEVEL="$MSG_DEBUG" _print_text "DEBUG:" "$@"
}
print_error() {
    MSG_LEVEL="$MSG_ERROR" _print_text "ERROR:" "$@"
}
# Print an error message and exit immediately
#   $1 : The message to send as an error
#   $2 : The exit code to use (default: 1)
die() {
    print_error "$1"
    exit "${2:-1}"
}

require_root() {
    if [[ "$EUID" -ne 0 ]]; then
        die "The $( basename "$0" ) script requires you run it as the root user."
    fi
}

run_help() {
    echo "Usage: $1"
    echo "  ./$SCRIPT_NAME STACK [PARAMS]"
    declare -a EXAMPLE_FUNCS
    readarray -t EXAMPLE_FUNCS < <(list_funcs_startswith help_examples_)
    if [[ ${#EXAMPLE_FUNCS[@]} -gt 0 ]]; then
        echo ""
        echo "Examples:"
    fi
    # Display example lines from sourced files
    # - Calls functions starting with `help_examples_`
    # - Displays them line by line, auto-indenting as appropriate
    for EXAMPLE_FUNC in "${EXAMPLE_FUNCS[@]}"; do
        while IFS= read -r LINE; do
            echo "  ${LINE#"${LINE%%[![:space:]]*}"}"
        done < <($EXAMPLE_FUNC)
    done
    echo ""
    echo "Parameters:"
    echo "  STACK"
    echo "      The name of the stack to operate on. Required."
    while IFS= read -r LINE; do
        # Indent lines not starting with hyphen
        if [[ $LINE != "-"* ]]; then
            echo -n "    "
        fi
        # Trim leading whitespace, as we're handling indentation
        echo "  ${LINE#"${LINE%%[![:space:]]*}"}"
    done < <(printf '%s\n' "${FLAG_HELP[@]}")
    echo "  -q|--quiet"
    echo "      Don't output any messages unless an error is encountered."
    echo "  -v|--verbose"
    echo "      Show verbose output. Can be specified multiple times."
    echo "  --debug"
    echo "      Show debug output. Identical to passing -vvv flags."
    echo ""
}

current_node() {
    hostname -s | cut -d- -f 2
}

node_hostname() {
    # shellcheck disable=SC2001
    echo "${DEPLOY_HOST_1:-$( hostname -s )}" | sed -e "s/-[1-3]/-${1}/"
}

node_list() {
    for NODE in {1..3}; do
        node_hostname "$NODE"
    done
}

# Given a set of arguments, split single char flags apart
# E.g. "-vv -glt -- -bt --read-only myfile.txt" => "-v -v -g -l -t -bt --read-only myfile.txt"
split_flags() {
    declare STOPFLAG=0
    declare -a NEWARGS
    while [[ $# -gt 0 ]]; do
        if [[ $1 == '--' ]]; then
            STOPFLAG=1
        elif [[ $STOPFLAG -eq 0 && $1 =~ ^-([a-zA-Z0-9]*)$ ]]; then
            while IFS= read -r -n1 FLAG; do
                if [[ -n $FLAG ]]; then
                    NEWARGS+=("-${FLAG}")
                fi
            done <<< "${BASH_REMATCH[1]}"
        else
            NEWARGS+=("$1")
        fi
        shift
    done
    echo -n "${NEWARGS[@]}"
}

list_funcs_startswith() {
    declare -a FUNCS
    while IFS= read -r LINE; do
        if [[ $LINE == "$1"* ]]; then
            # shellcheck disable=SC2206
            FUNCS+=($LINE)
        fi
    done < <(declare -F | sed -E 's/^declare -f //')
    printf '%s\n' "${FUNCS[@]}" | sort
}

# This function is used in defining flags dynamicaly; once the variables are defined
# then this function should be called to print them in a safe format.
format_flag_info() {
    printf "%s\t" "$VAR_NAME" "$FLAG_PATTERN" "$HELP_TEXT" "$VAR_DEFAULT" "$VAR_IS_BOOL"
    printf "\n"
}

load_flags() {
    declare -g -A FLAG_BOOL_REGISTRY
    declare -g -A FLAG_DEFAULT_REGISTRY
    declare -g -A FLAG_PATTERN_REGISTRY
    declare -g -a FLAG_HELP
    declare -a FLAG_ARGS_FUNCS
    readarray -t FLAG_ARGS_FUNCS < <(list_funcs_startswith parse_flags_)
    for FLAG_ARGS_FUNC in "${FLAG_ARGS_FUNCS[@]}"; do
        while IFS=$'\t' read -r VAR_NAME FLAG_PATTERN HELP_TEXT VAR_DEFAULT VAR_IS_BOOL; do
            declare NOT_BOOL_SUFFIX=
            if [[ $VAR_IS_BOOL -eq 0 ]]; then
                NOT_BOOL_SUFFIX="$VAR_NAME"
            fi
            declare -g "ARG_${VAR_NAME}=${VAR_DEFAULT}"
            FLAG_BOOL_REGISTRY[ARG_$VAR_NAME]=$VAR_IS_BOOL
            FLAG_DEFAULT_REGISTRY[ARG_$VAR_NAME]=$VAR_DEFAULT
            FLAG_PATTERN_REGISTRY[ARG_$VAR_NAME]=$FLAG_PATTERN
            FLAG_HELP+=("$FLAG_PATTERN $NOT_BOOL_SUFFIX" "$HELP_TEXT")
        done < <($FLAG_ARGS_FUNC)
    done
}

parse_args() {
    declare POSITION=0
    while [[ $# -gt 0 ]]; do
        for VAR_NAME in "${!FLAG_PATTERN_REGISTRY[@]}"; do
            case "$1" in
            "${FLAG_PATTERN_REGISTRY[$VAR_NAME]}")
                if [[ ${FLAG_BOOL_REGISTRY[$VAR_NAME]} -eq 1 ]]; then
                    declare -g "$VAR_NAME=$(( ! FLAG_DEFAULT_REGISTRY[$VAR_NAME] ))"
                    shift
                    continue 2
                else
                    declare -g "$VAR_NAME=$2"
                    shift 2
                    continue 2
                fi
                ;;
            esac
        done

        case "$1" in
        -q|--quiet)
            (( LOG_LEVEL = 0 ))
            shift
            ;;
        -v|--verbose)
            (( LOG_LEVEL += 1 ))
            shift
            ;;
        --debug)
            (( LOG_LEVEL = 4 ))
            shift
            ;;
        *)
            # TODO: handle dynamic positional arguments (might be a tough problem)
            case "${POSITION}" in
            0)
                # shellcheck disable=SC2034
                ARG_STACK=$1
                shift
                ;;
            1)
                die "Unknown argument: $1"
                ;;
            esac
            (( POSITION += 1 ))
        esac
    done
}

get_local_container() {
    declare DEPLOYMENT="$1" # E.g. devel-feature, catalog-beta
    declare SERVICE="$2"    # E.g. mariadb_galera, catalog_catalog
    declare CONTAINER_NAME=
    while read -r LINE; do
        if [[ "$LINE" == "${DEPLOYMENT}-${SERVICE}"* ]]; then
            CONTAINER_NAME="$LINE"
            break;
        fi
    done < <( docker container ls -f "status=running" -f "name=${DEPLOYMENT}-" --format "{{ .Names }}" )
    printf '%s' "$CONTAINER_NAME"
}

get_node_container() {
    declare NODE_HOSTNAME=$(node_hostname "$1")
    declare DEPLOYMENT="$2" # E.g. devel-feature, catalog-beta
    declare SERVICE="$3"    # E.g. mariadb_galera, catalog_catalog
    declare CONTAINER_NAME=
    while read -r LINE; do
        if [[ "$LINE" == "${DEPLOYMENT}-${SERVICE}"* ]]; then
            CONTAINER_NAME="$LINE"
            break;
        fi
    done < <( ssh "${SSH_USER+${SSH_USER}@}${NODE_HOSTNAME}" "docker container ls -f 'status=running' -f 'name=${DEPLOYMENT}-' --format '{{ .Names }}'" )
    printf '%s' "$CONTAINER_NAME"
}

get_service_image() {
    declare NODE_HOSTNAME=$(node_hostname 1) # The service command returns identical results on all nodes
    declare DEPLOYMENT="$1" # E.g. devel-feature, catalog-beta
    declare SERVICE="$2"    # E.g. mariadb_galera, catalog_catalog

    # Due to docker service's filter parameter not accepting exact matches, we have to post process to make sure we're matching
    # the correct one (i.e. cron not croncache)
    # https://github.com/moby/moby/issues/32985
    IMAGE=$(ssh "${SSH_USER+${SSH_USER}@}${NODE_HOSTNAME}" "docker service ls --format='{{.Image}} {{.Name}}' -f 'name=${DEPLOYMENT}-${SERVICE}'")
    IMAGE=$(echo "$IMAGE" | grep "${DEPLOYMENT}-${SERVICE}$" | awk '{print $1}')
    printf '%s' "$IMAGE"
}

get_service_node() {
    declare NODE_HOSTNAME=$(node_hostname 1) # The service command returns identical results on all nodes
    declare DEPLOYMENT="$1" # E.g. devel-feature, catalog-beta
    declare SERVICE="$2"    # E.g. mariadb_galera, catalog_catalog

    # Due to docker service's filter parameter not accepting exact matches, we have to post process to make sure we're matching
    # the correct one (i.e. cron not croncache)
    # https://github.com/moby/moby/issues/32985
    NODE=$(ssh "${SSH_USER+${SSH_USER}@}${NODE_HOSTNAME}" "docker service ps ${DEPLOYMENT}-${SERVICE} --format='{{.Node}} {{.Name}}' -f 'desired-state=running'")
    # Filter out services that don't match the name, get only the node name, get only the first result, get the 9th character (the node number)
    NODE=$(echo "$NODE" | grep "${DEPLOYMENT}-${SERVICE}." | awk '{print $1}' | head -1 | cut -c9)
    printf '%s' "$NODE"
}

run_on_node() {
    declare NODE_HOSTNAME=$(node_hostname "$1")
    declare CMD="$2"

    ssh "${SSH_USER+${SSH_USER}@}${NODE_HOSTNAME}" "$CMD"
    EC=$?
    return $EC
}

run_on_all_nodes() {
    declare CMD="$1"
    declare NODE
    declare PIDS=()
    declare ECS=()

    # Kick off the command on each node, and capture the pid
    for NODE in {1..3}; do
        run_on_node "$NODE" "$CMD" &
        PIDS+=($!)
    done

    # Wait for each command to complete and capture the exit code
    for PID in "${PIDS[@]}"; do
      wait "$PID"
      ECS+=("$?")
    done

    # Check exit codes for errors
    for ((i=0; i<${#ECS[@]}; i++)); do
        if [[ ${ECS[$i]} -ne 0 ]]; then
            NODE=$((i+1))
            print_error "Command on node $NODE exited with code ${ECS[$i]}"
            return "${ECS[$i]}"
        fi
    done

    return 0
}

run_on_all_nodes_with_retry() {
    declare CMD="$1"
    declare MAX_ATTEMPTS="$2"
    ATTEMPTS=1

    print_verbose "(Attempt $ATTEMPTS/$ARG_MAX_ATTEMPTS) Attempting to run command on all hosts: $CMD"
    while (( ATTEMPTS <= MAX_ATTEMPTS )); do
        run_on_all_nodes "$CMD"
        EC=$?
        if [[ $EC -eq 0 ]]; then
            print_info "(Attempt $ATTEMPTS/$MAX_ATTEMPTS) Successfully ran command on all hosts: $CMD"
            return 0
        else
            print_error "(Attempt $ATTEMPTS/$MAX_ATTEMPTS) Failed to run command on all hosts. Exit Code: $EC. Command: $CMD"
        fi
        # Wait before retrying
        sleep 1
        ((ATTEMPTS++))
    done

    # If we reached this point, then we've gone past the max attempts
    return 1
}

run_in_local_service() {
    declare DEPLOYMENT="$1" # E.g. devel-feature, catalog-beta
    declare SERVICE="$2"    # E.g. mariadb_galera, catalog_catalog
    declare CMD="$3"
    declare CONTAINER_NAME=$(get_local_container "$DEPLOYMENT" "$SERVICE")

    docker exec -i "$CONTAINER_NAME" bash <<< "$CMD"
}

run_in_node_service() {
    declare NODE_HOSTNAME=$(node_hostname "$1")
    declare DEPLOYMENT="$2" # E.g. devel-feature, catalog-beta
    declare SERVICE="$3"    # E.g. mariadb_galera, catalog_catalog
    declare CMD="$4"
    declare CONTAINER_NAME=$(get_node_container "$1" "$DEPLOYMENT" "$SERVICE")

    printf '%s\n' "$CMD" | ssh "${SSH_USER+${SSH_USER}@}${NODE_HOSTNAME}" "docker exec -i $CONTAINER_NAME bash -"
}

mariadb_defaults_file() {
    declare -g MARIADB_DEFAULTS_PATH;
    if [[ -z $MARIADB_DEFAULTS_PATH || ! -f $MARIADB_DEFAULTS_PATH ]]; then
        MARIADB_DEFAULTS_PATH="$(mktemp -d)/.my.cnf";
        # shellcheck disable=SC2094
        {
            echo "[client]";
            chmod 600 "$MARIADB_DEFAULTS_PATH";
            echo "user = root";
            echo "password = $(cat "$MARIADB_ROOT_PASSWORD_FILE")";
            echo "database = vufind";
        } > "$MARIADB_DEFAULTS_PATH";
    fi;
    printf '%s' "$MARIADB_DEFAULTS_PATH";
}

run_local_sql() {
    declare DEPLOYMENT="$1"
    declare QUERY="$2"
    declare CONTAINER_NAME=$(get_local_container "$DEPLOYMENT" mariadb_galera)

    run_in_local_service "$DEPLOYMENT" mariadb_galera "$(declare -f mariadb_defaults_file); mariadb --defaults-file=\$(mariadb_defaults_file) -N -e $(printf '%q' "$QUERY")"
}

# Run a SQL query and set results as global variables
# Returns: The exit code frmo the docker exec command
# Globals set:
#   ROW_CNT (int): Number of rows returned. Always set.
#   ROW_0 (array): The first row of values returned. Always set.
#   ROW_N (where N is int, array): More rows of values returned. Only set if a row exists.
run_local_sql_to_rows() {
    declare DEPLOYMENT="$1"
    declare QUERY="$2"
    declare CONTAINER_NAME=$(get_local_container "$DEPLOYMENT" mariadb_galera)

    declare -g ROW_CNT=0
    declare -g -a ROW_$ROW_CNT=
    while read -r -a ROW_$ROW_CNT; do
        (( ROW_CNT+=1 ))
        declare -g -a ROW_$ROW_CNT
    done < <( run_local_sql "$DEPLOYMENT" "$QUERY" )
    ECODE=$?
    # For some added safety, remove the unused last row var
    unset ROW_$ROW_CNT
    return $ECODE
}

run_sql_on_node() {
    declare NODE="$1"
    declare DEPLOYMENT="$2"
    declare QUERY="$3"

    run_in_node_service "$NODE" "$DEPLOYMENT" mariadb_galera "$(declare -f mariadb_defaults_file); mariadb --defaults-file=\$(mariadb_defaults_file) -N -e $(printf '%q' "$QUERY")"
}

run_sql_on_node_to_rows() {
    declare NODE="$1"
    declare DEPLOYMENT="$2"
    declare QUERY="$3"
    declare CONTAINER_NAME=$(get_node_container "$1" "$DEPLOYMENT" mariadb_galera)

    declare -g ROW_CNT=0
    declare -g -a ROW_$ROW_CNT=
    while IFS=$' \t' read -r -a ROW_$ROW_CNT; do
        (( ROW_CNT+=1 ))
        declare -g -a ROW_$ROW_CNT
    done < <( run_in_node_service "$NODE" "$DEPLOYMENT" mariadb_galera "$(declare -f mariadb_defaults_file); mariadb --defaults-file=\$(mariadb_defaults_file) -N -e $(printf '%q' "$QUERY")" )
    ECODE=$?
    # For some added safety, remove the unused last row var
    unset ROW_$ROW_CNT
    return $ECODE
}

# Given a number of seconds, convert that to D:H:M:S format
# Args:
#   $1: (int) number of seconds
format_seconds() {
    SECONDS=$1
    date -ud "@$SECONDS" +"$(( SECONDS/3600/24 )):%H:%M:%S (D:H:M:S)"
}

# Check if this script is being run in a screen session
# If not, ask the user to confirm if they want to continue
warn_if_not_in_screen() {
    if ! [[ "$TERM" == screen* ]]; then
        read -p "This script will likely run for a long time. You are currently not running this in a screen session. Do you want to continue anyways? [Y/n] " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            die "${RED}Cancelling import${RESET}"
        fi
    fi
}
