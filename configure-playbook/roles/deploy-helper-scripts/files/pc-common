#!/bin/bash

please_do_not_run_me() {
    # This script is a place to stored shared variables and functions used by other scripts.
    # Do not run this script directly; it does nothing.
    if [[ $0 == ${BASH_SOURCE[0]} ]]; then
        SCRIPT_NAME=$( basename "$0" )
        echo "The $SCRIPT_NAME script is not intended to be run directly. Rather it contains"
        echo "shared code sourced by other pc-* scripts."
        exit 1
    fi
}
please_do_not_run_me

# Init log level variables, setting default log level
# If unspecified, the log level will be 1 (WARNING)
init_log_level() {
    declare -g LOG_LEVEL=${1:-1}
    declare -g -r MSG_ERROR=-1
    declare -g -r MSG_QUIET=0
    declare -g -r MSG_WARNING=1
    declare -g -r MSG_INFO=2
    declare -g -r MSG_VERBOSE=3
    declare -g -r MSG_DEBUG=4
}

# Call all other functions starting with `init_args_` with intent
# to declare and initialize defaults for argument variables
init_args() {
    declare -a INIT_ARGS_FUNCS=($(list_funcs_startswith init_args_))
    for INIT_ARGS_FUNC in "${INIT_ARGS_FUNCS[@]}"; do
        $INIT_ARGS_FUNC
    done
}

# Print script messages to stderr, requires var MSG_LEVEL be set
# Not to be called directly; use other print_* function instead.
_print_text() {
    if [[ $LOG_LEVEL -gt $MSG_LEVEL || $LOG_LEVEL -lt 0 ]]; then
        LOG_TS=$(date +%Y-%m-%d\ %H:%M:%S)
        MSG="[${LOG_TS}] $*"
        1>&2 echo "$MSG"
    fi
}
print_warning() {
    MSG_LEVEL="$MSG_WARNING" _print_text "WARNING:" "$@"
}
print_info() {
    MSG_LEVEL="$MSG_INFO" _print_text "$@"
}
print_verbose() {
    MSG_LEVEL="$MSG_VERBOSE" _print_text "$@"
}
print_debug() {
    MSG_LEVEL="$MSG_DEBUG" _print_text "DEBUG:" "$@"
}
print_error() {
    MSG_LEVEL="$MSG_ERROR" _print_text "ERROR:" "$@"
}
# Print an error message and exit immediately
#   $1 : The message to send as an error
#   $2 : The exit code to use (default: 1)
die() {
    print_error "$1"
    exit ${2:-1}
}

require_root() {
    if [[ "$EUID" -ne 0 ]]; then
        die "The $( basename "$0" ) script requires you run it as the root user."
    fi
}

node_hostname() {
    hostname -s | sed -e "s/-[1-3]/-${1}/"
}

node_list() {
    for NODE in {1..3}; do
        node_hostname $NODE
    done
}

# Given a set of arguments, split single char flags apart
# E.g. "-vv -glt -- -bt --read-only myfile.txt" => "-v -v -g -l -t -bt --read-only myfile.txt"
split_flags() {
    local STOPFLAG=0
    local -a NEWARGS
    while [[ $# -gt 0 ]]; do
        if [[ $1 == '--' ]]; then
            STOPFLAG=1
        elif [[ $STOPFLAG -eq 0 && $1 =~ ^-([a-zA-Z0-9]*)$ ]]; then
            while IFS= read -r -n1 FLAG; do
                if [[ -n $FLAG ]]; then
                    NEWARGS+=("-${FLAG}")
                fi
            done <<< "${BASH_REMATCH[1]}"
        else
            NEWARGS+=("$1")
        fi
        shift
    done
    echo -n "${NEWARGS[@]}"
}

list_funcs_startswith() {
    local -a FUNCS
    while IFS= read -r LINE; do
        if [[ $LINE == "$1"* ]]; then
            FUNCS+=($LINE)
        fi
    done < <(declare -F | sed -E 's/^declare -f //')
    printf '%s\n' "${FUNCS[@]}" | sort
}

# This function is used in defining flags dynamicaly; once the variables are defined
# then this function should be called to print them in a safe format.
format_flag_info() {
    printf "%s\t" "$VAR_NAME" "$FLAG_PATTERN" "$HELP_TEXT" "$VAR_DEFAULT" "$VAR_IS_BOOL"
    printf "\n"
}

load_flags() {
    declare -g -A FLAG_BOOL_REGISTRY
    declare -g -A FLAG_DEFAULT_REGISTRY
    declare -g -A FLAG_PATTERN_REGISTRY
    declare -g -a FLAG_HELP
    declare -a FLAG_ARGS_FUNCS=($(list_funcs_startswith parse_flags_))
    for FLAG_ARGS_FUNC in "${FLAG_ARGS_FUNCS[@]}"; do
        while IFS=$'\t' read -r VAR_NAME FLAG_PATTERN HELP_TEXT VAR_DEFAULT VAR_IS_BOOL; do
            declare NOT_BOOL_SUFFIX=
            if [[ $VAR_IS_BOOL -eq 0 ]]; then
                NOT_BOOL_SUFFIX="$VAR_NAME"
            fi
            declare -g "ARG_${VAR_NAME}=${VAR_DEFAULT}"
            FLAG_BOOL_REGISTRY[ARG_$VAR_NAME]=$VAR_IS_BOOL
            FLAG_DEFAULT_REGISTRY[ARG_$VAR_NAME]=$VAR_DEFAULT
            FLAG_PATTERN_REGISTRY[ARG_$VAR_NAME]=$FLAG_PATTERN
            FLAG_HELP+=("$FLAG_PATTERN $NOT_BOOL_SUFFIX" "$HELP_TEXT")
        done < <($FLAG_ARGS_FUNC)
    done
}

parse_args() {
    declare POSITION=0
    while [[ $# -gt 0 ]]; do
        for VAR_NAME in "${!FLAG_PATTERN_REGISTRY[@]}"; do
            case "$1" in
            ${FLAG_PATTERN_REGISTRY[$VAR_NAME]})
                if [[ ${FLAG_BOOL_REGISTRY[$VAR_NAME]} -eq 1 ]]; then
                    declare -g "$VAR_NAME=$(( ! FLAG_DEFAULT_REGISTRY[$VAR_NAME] ))"
                    shift
                    continue 2
                else
                    declare -g "$VAR_NAME=$2"
                    shift 2
                    continue 2
                fi
                ;;
            esac
        done

        case "$1" in
        -h|--help)
            run_help
            exit 0
            ;;
        -q|--quiet)
            (( LOG_LEVEL = 0 ))
            shift
            ;;
        -v|--verbose)
            (( LOG_LEVEL += 1 ))
            shift
            ;;
        --debug)
            (( LOG_LEVEL = 4 ))
            shift
            ;;
        *)
            # TODO: handle dynamic positional arguments (might be a tough problem)
            case "${POSITION}" in
            0)
                ARG_STACK=$1
                shift
                ;;
            1)
                die "Unknown argument: $1"
                ;;
            esac
            (( POSITION += 1 ))
        esac
    done
}

get_local_container() {
    DEPLOYMENT="$1" # E.g. devel-feature, catalog-beta
    SERVICE="$2"    # E.g. mariadb_galera, catalog_catalog
    CONTAINER_NAME=
    while read -r LINE; do
        if [[ "$LINE" == "${DEPLOYMENT}-${SERVICE}"* ]]; then
            CONTAINER_NAME="$LINE"
            break;
        fi
    done < <( docker container ls -f "status=running" -f "name=${DEPLOYMENT}-" --format "{{ .Names }}" )
    printf '%s' "$CONTAINER_NAME"
}

get_node_container() {
    NODE_HOSTNAME=$(node_hostname "$1")
    DEPLOYMENT="$2" # E.g. devel-feature, catalog-beta
    SERVICE="$3"    # E.g. mariadb_galera, catalog_catalog
    CONTAINER_NAME=
    while read -r LINE; do
        if [[ "$LINE" == "${DEPLOYMENT}-${SERVICE}"* ]]; then
            CONTAINER_NAME="$LINE"
            break;
        fi
    done < <( ssh $NODE_HOSTNAME "docker container ls -f 'status=running' -f 'name=${DEPLOYMENT}-' --format '{{ .Names }}'" )
    printf '%s' "$CONTAINER_NAME"
}

run_on_node() {
    NODE_HOSTNAME=$(node_hostname "$1")
    CMD="$2"

    ssh $NODE_HOSTNAME "$CMD"
}

run_in_local_service() {
    DEPLOYMENT="$1" # E.g. devel-feature, catalog-beta
    SERVICE="$2"    # E.g. mariadb_galera, catalog_catalog
    CMD="$3"
    CONTAINER_NAME=$(get_local_container "$DEPLOYMENT" "$SERVICE")

    docker exec -i "$CONTAINER_NAME" bash -c "$CMD"
}

run_in_node_service() {
    NODE_HOSTNAME=$(node_hostname "$1")
    DEPLOYMENT="$2" # E.g. devel-feature, catalog-beta
    SERVICE="$3"    # E.g. mariadb_galera, catalog_catalog
    CMD="$4"
    CONTAINER_NAME=$(get_node_container "$1" "$DEPLOYMENT" "$SERVICE")

    ssh $NODE_HOSTNAME "docker exec -i \"${CONTAINER_NAME}\" bash -c \"${CMD}\""
}

mariadb_defaults_file() {
    declare -g MARIADB_DEFAULTS_PATH
    if [[ -z $MARIADB_DEFAULTS_PATH || ! -f $MARIADB_DEFAULTS_PATH ]]; then
        MARIADB_DEFAULTS_PATH="$(mktemp -d)/.my.cnf"
        echo "[client]"                                         > "$MARIADB_DEFAULTS_PATH"
        chmod 600 "$MARIADB_DEFAULTS_PATH"
        echo "user = root"                                     >> "$MARIADB_DEFAULTS_PATH"
        echo "password = $(cat "$MARIADB_ROOT_PASSWORD_FILE")" >> "$MARIADB_DEFAULTS_PATH"
        echo "database = vufind"                               >> "$MARIADB_DEFAULTS_PATH"
    fi
    printf '%s' "$MARIADB_DEFAULTS_PATH"
}

# Run a SQL query and set results as global variables
# Returns: The exit code frmo the docker exec command
# Globals set:
#   ROW_CNT (int): Number of rows returned. Always set.
#   ROW_0 (array): The first row of values returned. Always set.
#   ROW_N (where N is int, array): More rows of values returned. Only set if a row exists.
run_local_sql() {
    DEPLOYMENT="$1"
    QUERY="$2"
    CONTAINER_NAME=$(get_local_container "$DEPLOYMENT" mariadb_galera)

    declare -g ROW_CNT=0
    declare -g -a ROW_$ROW_CNT=
    while read -r -a ROW_$ROW_CNT; do
        (( ROW_CNT+=1 ))
        declare -g -a ROW_$ROW_CNT
    done < <( docker exec -i "${CONTAINER_NAME}" bash -c "$(declare -f mariadb_defaults_file); mariadb --defaults-file=\$(mariadb_defaults_file) -N -e $(printf '%q' "$QUERY")" )
    ECODE=$?
    # For some added safety, remove the unused last row var
    unset ROW_$ROW_CNT
    return $ECODE
}

run_sql_on_node() {
    NODE_HOSTNAME=$(node_hostname "$1")
    DEPLOYMENT="$2"
    QUERY="$3"
    CONTAINER_NAME=$(get_node_container "$1" "$DEPLOYMENT" mariadb_galera)

    declare -g ROW_CNT=0
    declare -g -a ROW_$ROW_CNT=
    while read -r -a ROW_$ROW_CNT; do
        (( ROW_CNT+=1 ))
        declare -g -a ROW_$ROW_CNT
    done < <( ssh $NODE_HOSTNAME "$(declare -f mariadb_defaults_file); docker exec -i \"${CONTAINER_NAME}\" bash -c \"\$(declare -f mariadb_defaults_file); mariadb --defaults-file=\\\$(mariadb_defaults_file) -N -e $(sed -e 's/"/\\\\"/g' <<< $(printf '%q' "$QUERY"))\"" )
    ECODE=$?
    # For some added safety, remove the unused last row var
    unset ROW_$ROW_CNT
    return $ECODE
}
