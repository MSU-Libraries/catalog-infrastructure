#!/bin/bash

SCRIPT_NAME=$( basename "$0" )

init_var_defaults() {
    declare -g SEARCH_DIR="/mnt/shared/oai"
    declare -g SEARCH_SUBDIR="harvest_folio/processed" # within $SEARCH_DIR/[STACK]
    declare -g ARG_STACK="catalog-prod"
    declare -g ARG_VERBOSE=0
    declare -g ARG_DEBUG=0
    declare -g ARG_EXTRACT=0
    declare -g ARG_RECENT=0
    declare -g -a ARG_INSTANCE_IDS
    declare -g -A INSTANCE_RECORDS
}
init_var_defaults

runhelp() {
    echo ""
    echo "Usage: Locate the OAI file by the FOLIO instance ID"
    echo "    ./$SCRIPT_NAME INSTANCE_IDS [STACK_NAME] [FLAGS]"
    echo ""
    echo "Examples: "
    echo "   ./$SCRIPT_NAME in00005342798"
    echo "     Locate the OAI file containing in00005342798 within catalog-prod's files"
    echo "   ./$SCRIPT_NAME in00005342798,in00001442723 catalog-beta"
    echo "     Locate the OAI files containing any of listed instances within catalog-beta's files"
    echo "   ./$SCRIPT_NAME in00005342798,in00001442723 catalog-beta --extract"
    echo "     Copy records matching instances from catalog-beta OAI files to a new temp XML file"
    echo ""
    echo "ARGS:"
    echo "  INSTANCE_IDS"
    echo "      Comma delimited list of instance ids; no spaces allowed. Required."
    echo "  STACK_NAME"
    echo "      The stack under which to search for OAI file matches. Default: catalog-prod"
    echo "  -e|--extract"
    echo "      Extract records matching all given INSTANCE_IDS and save them into a new xml file."
    echo "  -r|--recent"
    echo "      Match only the most recent file containing each instance id"
    echo "  -v|--verbose"
    echo "      Show verbose output."
    echo "  --debug"
    echo "      Show debug output. Implies --verbose"
    echo ""
}

verbose() {
    LOG_TS=$(date +%Y-%m-%d\ %H:%M:%S)
    MSG="[${LOG_TS}] $*"
    if [[ $STDERR -eq 1 ]]; then
        1>&2 echo "$MSG"
    elif [[ ${ARG_VERBOSE} -eq 1 ]]; then
        echo "$MSG"
    fi
}

error() {
    declare -g STDERR
    STDERR=1
    verbose "ERROR: $*"
    STDERR=0
}

debug() {
    if [[ $ARG_DEBUG -eq 1 ]]; then
        declare -g STDERR
        STDERR=1
        verbose "Debug: $*"
        STDERR=0
    fi
}

die() {
    error "$*"
    exit 1
}


# Print help message
if [[ -z "$1" || $1 == "-h" || $1 == "--help" || $1 == "help" ]]; then
    runhelp
    exit 0
fi

# Parse command arguments
parse_args() {
    local POSITION=0
    # Parse flag arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
        -h|--help)
            runhelp
            exit 0
            ;;
        -v|--verbose)
            ARG_VERBOSE=1
            shift;;
        -r|--recent)
            ARG_RECENT=1
            shift;;
        -e|--extract)
            ARG_EXTRACT=1
            shift;;
        --debug)
            ARG_VERBOSE=1
            ARG_DEBUG=1
            shift;;
        *)
            case "${POSITION}" in
            0)
                VALID_IDS_PATTERN="^in[0-9]{11}(,in[0-9]{11})*$"
                if [[ ! $1 =~ $VALID_IDS_PATTERN ]]; then
                    die "Invalid INSTANCE_IDS list"
                fi
                # sorting instances for laster ease in comparing which weren't found
                # shellcheck disable=SC2207
                IFS=$'\n' ARG_INSTANCE_IDS=($(sort <<< "${1//,/$'\n'}"))
                unset IFS
                POSITION=1
                shift ;;
            1)
                ARG_STACK=$1
                if [[ ! -d "${SEARCH_DIR}"/"${1}" ]]; then
                    die "OAI does not exist for the given environment: ${SEARCH_DIR}/$1"
                fi
                POSITION=2
                shift ;;
            2)
                error "Unknown argument: $1"
                runhelp
                exit 1
            esac
        esac
    done
}

# Does additional validation of the values in the command parameters
# and will exit if not met
catch_invalid_args() {
    # Check for missing arguments
    if [[ -z "${ARG_INSTANCE_IDS[*]}" ]]; then
        die "INSTANCE_IDS is a required argument cannot be empty"
    fi
    if [[ ! -d "${SEARCH_DIR}/${ARG_STACK}/${SEARCH_SUBDIR}" ]]; then
        die "OAI directory not found: ${SEARCH_DIR}/${ARG_STACK}/${SEARCH_SUBDIR}"
    fi
}

match_files() {
    INSTANCE_MATCHES=()
    for INSTANCE_ID in "${ARG_INSTANCE_IDS[@]}"; do
        # shellcheck disable=SC2206
        INSTANCE_MATCHES+=(-e ${INSTANCE_ID})
    done
    debug "parallel -j 16 -n 16 grep -lF ${INSTANCE_MATCHES[*]} -- \"${FULL_SEARCH_DIR}\"/combined_20*.xml"
    # shellcheck disable=SC2048,SC2086
    parallel -j 16 -n 16 grep -lF ${INSTANCE_MATCHES[*]} -- "${FULL_SEARCH_DIR}"/combined_20*.xml
}

file_has_instance() {
    FILE_PATH="$1"
    INSTANCE_ID="$2"

    RECORD=$(xmlstarlet sel \
            -N marc="http://www.loc.gov/MARC21/slim" -t \
            -m "//collection/marc:record/marc:controlfield[@tag='001'][text()='$INSTANCE_ID']/.." \
            -c . -n "$FILE_PATH")
    FOUND=$?
    if [[ $FOUND -eq 0 ]]; then
        debug "Found instance $INSTANCE_ID in $( basename "${FILE_PATH}" )"
        INSTANCE_RECORDS[$INSTANCE_ID]="$RECORD"
    fi
    return $FOUND
}

filter_to_recent_files() {
    FILTERED_FILES=()
    for INSTANCE_ID in "${INSTANCE_IDS[@]}"; do
        for MATCHED_FILE in "${MATCHED_FILES[@]}"; do
            if file_has_instance "$MATCHED_FILE" "$INSTANCE_ID"; then
                # first instance found; no further checking required
                FILTERED_FILES+=("$MATCHED_FILE")
                continue 2
            fi
        done
    done
}

show_not_found_ids() {
    UNSORTED_FOUND_IDS=("${!INSTANCE_RECORDS[@]}")
    # shellcheck disable=SC2207
    IFS=$'\n' FOUND_IDS=($(sort <<< "${UNSORTED_FOUND_IDS[*]}"))
    unset IFS
    mapfile -t NOT_FOUND_IDS < <( \
        comm -1 -3 \
            <( IFS=$'\n'; echo "${FOUND_IDS[*]}" ) \
            <( IFS=$'\n'; echo "${INSTANCE_IDS[*]}" ) )

    if [[ ${#NOT_FOUND_IDS[@]} -gt 0 ]]; then
        debug "Did not find ${NOT_FOUND_IDS[*]}"
    fi
}

# Performs the search given the FOLIO instance ID and stack
main() {
    FULL_SEARCH_DIR=${SEARCH_DIR}/${ARG_STACK}/${SEARCH_SUBDIR}
    verbose "Searching for $(IFS=, ; echo "${ARG_INSTANCE_IDS[*]}") within ${FULL_SEARCH_DIR}"

    declare -g -a INSTANCE_IDS=("${ARG_INSTANCE_IDS[@]}")
    declare -g -a MATCHED_FILES
    mapfile -t MATCHED_FILES < <( match_files | sort -r )
    declare -g -a FILTERED_FILES=("${MATCHED_FILES[@]}")
    verbose "Found ${#FILTERED_FILES[@]} files that match."
    for FILTERED_FILE in "${FILTERED_FILES[@]}"; do
        debug "Matched $( basename "${FILTERED_FILE}" )"
    done
    if [[ ${ARG_RECENT} -eq 1 ]]; then
        verbose "Filtering to only most recent files with instance matches"
        filter_to_recent_files
        show_not_found_ids
    fi

    if [[ ${ARG_EXTRACT} -eq 0 ]]; then
        printf '%s\n' "${FILTERED_FILES[@]}"
    else
        TEMP_XML=$(mktemp --suffix=.xml)
        echo '<?xml version="1.0" ?>' > "$TEMP_XML"
        echo '<collection>' >> "$TEMP_XML"
        for INSTANCE_RECORD in "${INSTANCE_RECORDS[@]}"; do
            echo "$INSTANCE_RECORD" >> "$TEMP_XML"
        done
        echo '</collection>' >> "$TEMP_XML"
        echo "$TEMP_XML"
    fi
}

parse_args "$@"
catch_invalid_args
debug "$SCRIPT_NAME starting"
main
debug "$SCRIPT_NAME completed"
