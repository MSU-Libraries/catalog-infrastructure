#!/bin/bash

# Connect to a catalog container:
#   /usr/local/bin/pc-connect SERVICE HOST

# shellcheck disable=SC1091
SCRIPT_DIR=$( dirname "$0" )
source "${SCRIPT_DIR}/pc-common"

# Set defaults
default_args() {
    declare -g ARG_SERVICE=
    declare -g ARG_HOST=
    declare -g ARG_CMD=bash
    declare -g ARG_USER=
    declare -g ARG_DB=0
    declare -g ARG_ZK=0
    declare -g ARG_DRYRUN=0
    declare -g ARG_VERBOSE=0
    declare -g ARG_DEBUG=0
}
default_args

runhelp() {
    echo ""
    echo "Connect to a container"
    echo ""
    echo "Usage:"
    echo "   pc-connect [FLAGS] SERVICE [HOST]"
    echo ""
    echo "Examples: "
    echo "   pc-connect catalog-prod-catalog_catalog"
    echo "     Connects to the catalog-prod-catalog_catalog container on the running host"
    echo "   pc-connect catalog-prod-catalog_catalog 3"
    echo "     Connects to the catalog-prod-catalog_catalog container on the given host"
    echo "   pc-connect catalog-prod-catalog_catalog -n"
    echo "     Display what connection commands would be run for the service"
    echo ""
    echo "ARGS:"
    echo "  SERVICE"
    echo "      Required. Name of the service to connect to"
    echo "  HOST"
    echo "      Optional. Host node to connect to. Valid values are 1-3"
    echo "  -d|--db"
    echo "      Connect to the mysql service in the container. SHOULD ONLY BE USED ON *mariadb_galera SERVICES"
    echo "  -z|--zk"
    echo "      Connect to the zkshell service in the container. SHOULD ONLY BE USED ON *solr_solr SERVICES"
    echo "  -c|--cmd CMD"
    echo "      Command to run inside the container. Default: bash"
    echo "  -u|--user USER"
    echo "      Override the user to use within the container."
    echo "  -n|--dry-run"
    echo "      Do not perform any actions, just dry-run the output."
    echo "  -v|--verbose"
    echo "      Show verbose output."
    echo "  --debug"
    echo "      Display debugging messages (should be set before passing command arguments)."
    echo ""
}

message() {
    LOG_TS=$(date +%Y-%m-%d\ %H:%M:%S)
    1>&2 echo "[${LOG_TS}] $*"
}
verbose() {
    [[ ${ARG_DRYRUN} -eq 1 ]] && DRYRUN="(dry-run) "
    [[ ${ARG_VERBOSE} -eq 1 ]] && message "${DRYRUN}$*"
}
error() {
    message "ERROR: $*"
}
debug() {
    [[ ${ARG_DEBUG} -eq 1 ]] && message "Debug: $*"
}
die() {
    error "$*"
    exit 1
}

# Print help message
if [[ -z "$1" || $1 == "-h" || $1 == "--help" || $1 == "help" ]]; then
    runhelp
    exit 0
fi

# Parse command arguments
parse_args() {
    local POSITION=0
    # Parse flag arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
        -h|--help)
            runhelp
            exit 0
            ;;
        -n|--dry-run)
            ARG_DRYRUN=1
            ARG_VERBOSE=1
            shift;;
        -v|--verbose)
            ARG_VERBOSE=1
            shift;;
        --debug)
            ARG_DEBUG=1
            ARG_VERBOSE=1
            [[ -n "${ARG_SERVICE}" ]] && \
                die "The --debug flag must be set before SERVICE."
            shift;;
        -c|--cmd)
            ARG_CMD="$2"
            shift 2;;
        -u|--user)
            ARG_USER="$2"
            shift 2;;
        -d|--db)
            ARG_DB=1
            shift;;
        -z|--zk)
            ARG_ZK=1
            shift;;
        *)
            case "${POSITION}" in
            0)
                ARG_SERVICE=$1
                POSITION=1
                shift ;;
            1)
                ARG_HOST=$1
                if [[ $ARG_HOST =~ ^[1-3]$ ]]; then
                    ARG_HOST=$(node_hostname "$ARG_HOST")
                else
                    die "ERROR: Must provide a value node. Valid nodes are 1-3"
                fi
                POSITION=2
                shift ;;
            2)
                echo "ERROR: Unknown argument: $1"
                runhelp
                exit 1
            esac
        esac
    done
}

# Does additional validation of the values in the command parameters
# and will exit if not met
catch_invalid_args() {
    # Check for missing arguments
    [[ -z ${ARG_SERVICE} ]] \
        && die "SERVICE is a required argument"
    [[ -z ${ARG_CMD} ]] \
        && die "COMMAND is a required argument"

    # Checks if ZK or DB if set, then the required service must be set
    if [[ ${ARG_DB} -eq 1 ]] && [[ ${ARG_SERVICE} != *"mariadb_galera" ]]; then
        die "When --db is provided, the SERVICE must be *mariadb_galera"
    fi
    if [[ ${ARG_ZK} -eq 1 ]] && [[ ${ARG_SERVICE} != *"solr_solr" ]]; then
        die "When --zk is provided, the SERVICE must be *solr_solr"
    fi
}

get_host() {
    verbose "docker service ps \"${ARG_SERVICE}\" -f desired-state=running --format \"{{.Node}}\""
    if ! HOST=$(docker service ps "${ARG_SERVICE}" -f desired-state=running --format "{{.Node}}"); then
        die "Failed to locate service ${ARG_SERVICE}"
    fi
    echo "${HOST}" | sort | head -1
}

get_container() {
    verbose "ssh $1 docker ps -f name=${ARG_SERVICE} --format \"{{.Names}}\""
    ssh "$1" docker ps -f name="${ARG_SERVICE}" --format "{{.Names}}"
}

run_command() {
    # Find the host for the service (or use the one provided)
    DEPLOYMENT=${ARG_SERVICE%-*}
    SERVICE=${ARG_SERVICE##*-}
    NODE=$(get_service_node "$DEPLOYMENT" "$SERVICE")
    HOST=$(node_hostname "$NODE")
    if [[ -n ${ARG_HOST} ]]; then
        HOST=${ARG_HOST}
    fi

    debug "Attempting to connect to service ${ARG_SERVICE} on host ${HOST}"
    if ! CONTAINER=$(get_container "${HOST}"); then
        die "Failed to locate container for ${ARG_SERVICE} on ${HOST}"
    fi

    # Update command if needed
    if [[ ${ARG_DB} -eq 1 ]]; then
        ARG_CMD=connect
    elif [[ ${ARG_ZK} -eq 1 ]]; then
        ARG_CMD=solr-zk-shell
    fi

    # Connect to the container to run the command
    if [[ -n $ARG_USER ]]; then
        ARG_USER=" -u $ARG_USER"
    fi
    verbose "ssh -tt ${HOST} \"docker exec${ARG_USER} -it ${CONTAINER} ${ARG_CMD}\""
    if [[ ${ARG_DRYRUN} -eq 0 ]]; then
        if [[ -z $CONTAINER ]]; then
            die "Could not find $ARG_SERVICE on $HOST."
        fi
        ssh -tt "${HOST}" "docker exec ${ARG_USER} -it ${CONTAINER} ${ARG_CMD}"
    fi
}

# Deploy the Docker stack, exiting unsuccessfully if the deploy fails
main() {
    verbose "Service:     ${ARG_SERVICE}"
    run_command
}

# Parse and start running
# shellcheck disable=SC2046
parse_args $(split_flags "$@")

# Ensure user is root
if [[ $EUID -ne 0 ]]; then
    verbose "Running as sudo"
    exec sudo -H "$0" "$@"
fi

catch_invalid_args
main

